// Makernet revised core library rebuilt with improved hygene and ability to
// be tested and debugged on OSX

//  c++ -DMASTER makernet.cpp -o master && ./master
//  c++ -DSLAVE makernet.cpp -o slave && ./slave

// This option makes a ton of warnings go away...
// -std=c++11


/********************************************************
 *
 * <FILE>
 *
 * Part of the Makernet framework by Jeremy Gilbert
 *
 * License: GPL 3
 * See footer for copyright and license details.
 *
 ******/


/********************************************************
 *
 * Copyright (C) 2017 Jeremy Gilbert
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * If GPL 3 does not suit your needs, feel free to contact the author for
 * alternative licensing arrangements.
 *
 ********************************************************/










// util.h















// This is a subclass of the mailbox dictionary. Every peripheral should have
// one so that the mailbox configuration is constant between the peripheral
// code and the object host code. To use it, create member variables for each
// mailbox that could handle values. Then wire them up in the configure()
// function of the implementation.

class EncoderMailboxDictionary : public MailboxDictionary {
public:
	virtual void configure();
	SmallMailbox position   = SmallMailbox(DEVICE, "Encoder position");
	SmallMailbox buttonDown = SmallMailbox(DEVICE, "Button down");
	SmallMailbox buttonUp   = SmallMailbox(DEVICE, "Button up");
};





class EncoderPeripheral : public BasePeripheral {
public:
	EncoderPeripheral();
	virtual void configure();

	EncoderMailboxDictionary encoderDictionary;

};






void EncoderMailboxDictionary::configure()
{
	
		DPR( dANY, "Configuring encoder dictionary...");
	set(0, position);
	set(1, buttonDown);
	set(2, buttonUp);
}


EncoderPeripheral::EncoderPeripheral() :
	BasePeripheral(DeviceType::Encoder)
{
}

void EncoderPeripheral::configure()
{
	 encoderDictionary.configure();
}


EncoderPeripheral encoder;













// UnixMaster implements a Datalink layer for the UNIX testbed. This code is
// not intended to run on MCUs so needs an #if statement surround it.

class UnixMaster : public Datalink {
public:
	virtual void initialize();
	virtual int sendFrame( uint8_t *inBuffer, uint8_t len );
	int loop();
	void processIncomingFrame();
	bool handleSTDIN( char *b, int s );
	typedef void (*UserCommandHandler)(char *cmd, int len );
	UserCommandHandler handleCommand = NULL;

private:
	struct sockaddr_un remote;
	int sock;

	// Buffer for the user command line
	char userCommandBuffer[1000];
	char *bpos = userCommandBuffer;
};


#define SOCK_PATH "/tmp/echo_socket"

void UnixMaster::initialize()
{

	int t, len;

	char str[100];

	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
		perror("socket");
		exit(1);
	}

	DLN( dDATALINK, "Trying to connect...");

	remote.sun_family = AF_UNIX;
	strcpy(remote.sun_path, SOCK_PATH);
	len = strlen(remote.sun_path) + sizeof(remote.sun_family);
	if (connect(sock, (struct sockaddr *)&remote, len) == -1) {
		perror("connect");
		exit(1);
	}

	DLN( dDATALINK, "Connected.");

}

typedef struct { uint8_t value[5] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }; } ThunkMessage;

ThunkMessage thunk;

// Called by upper layers to send a frame.

int UnixMaster::sendFrame( uint8_t *inBuffer, uint8_t len )
{

	if (send(sock, &len, 1, 0) == -1) {
		perror("send");
		exit(1);
	}

	if (send(sock, inBuffer, len, 0) == -1) {
		perror("send");
		exit(1);
	}

	DPR( dDATALINK, "<<<< (" );
	DPR( dDATALINK, len );
	DPR( dDATALINK, ") ");
	hexPrint( dDATALINK, inBuffer, len );
	DLN( dDATALINK );

	// Emit the "thunk". If we are a master, we need to emulate the idea of
	// opening the bus for responses the same way that I2C works when the
	// master holds the clock line after its finished sending. This happens by
	// emitting a 5 byte FF signature.

	if ( Makernet.network.role == Network::master ) {
		int len = sizeof( thunk );

		if (send(sock, &len, 1, 0) == -1) {
			perror("send");
			exit(1);
		}
		if ( send(sock, (uint8_t *)&thunk, 5, 0) == -1 ) {
			perror("send");
			exit(1);
		}
	}

	return 0;
}

void UnixMaster::processIncomingFrame()
{
	int t;

	uint8_t frameLen;

	t = recv(sock, &frameLen, 1, MSG_WAITALL);

	if ( t <= 0 ) {
		if (t < 0)
			perror("recv");
		else
			printf("Server closed connection\n");
		exit(1);
	}

//	DPF( "Frame len:[%d]\n", frameLen );

	if ((t = recv(sock, frameBuffer, frameLen, MSG_WAITALL)) > 0) {
		frameBuffer[t] = '\0';

		DPR( dDATALINK, ">>>> (" );
		DPR( dDATALINK, t );
		DPR( dDATALINK, ") ");
		hexPrint( dDATALINK, frameBuffer, t );
		DLN( dDATALINK );

		// Intercept a master broadcast "thunk". This emulation is only
		// handled in cases where we are pretending to be a master/slave
		// network and the thunk triggers the poll.

		if ( t == 5 and Makernet.network.role == Network::slave )
			if ( memcmp( &thunk, frameBuffer, 5) == 0 )
			{
				for ( int i = 0 ; i < MAX_MAKERNET_FRAME_LENGTH ; i++ )
					frameBuffer[i] = 0;

				int n = Makernet.network.pollFrame( frameBuffer, n );
				if ( n > 0 )
					sendFrame( frameBuffer, n );

				return;
			}

		// Dispatch the frame up to the higher levels of the network

		if ( t > 0 )
			Makernet.network.handleFrame( frameBuffer, t );
	} else {
		if (t < 0)
			perror("recv");
		else
			printf("Server closed connection\n");
		exit(1);
	}
}

bool UnixMaster::handleSTDIN( char *b, int s )
{
	for ( int i = 0 ; i < s ; i++ )
	{
		if ( b[i] == '\n') {
			b[i] = '\0';
			printf( "*** Command from STDIN: [%s]\n", b );
			if ( handleCommand != NULL )
				handleCommand( b, s );
			return true;
		}
	}

	return false;

}

int UnixMaster::loop()
{
	struct pollfd fds[2];

	const int stdin = 0;

	fds[0].fd = stdin; /* this is STDIN */
	fds[0].events = POLLIN;
	fds[1].fd = sock; /* this is our socket */
	fds[1].events = POLLIN;

	if ( poll( fds, 2, 1000 ) > 0 ) {
		// Handle stdin
		if ( fds[0].revents & POLLIN ) {

			int r = read(stdin, bpos, 1000 + userCommandBuffer - bpos);
			// printf( "**** read from STDIN: [%d] bytes\n", r );
			bpos += r;
			if ( handleSTDIN( userCommandBuffer, bpos - userCommandBuffer )) {
				// DLN( dDATALINK, "reset" );
				bpos = userCommandBuffer;
			}
		}

		// Handle network input
		if ( fds[1].revents & POLLIN )
			processIncomingFrame();
	}
	return 0;
}





//#define MASTER





#ifdef MASTER





int main(void)
{
	FAKEHARDWAREID = 0x8877;

	DeviceControlService dcs;
	Makernet.network.role = Network::master;
	UnixMaster um;

	Makernet.network.useDatalink( &um );
	Makernet.network.registerService(DCS_DEFAULT_PORT, &dcs);

	Makernet.initialize();

	startMicrosecondCounter();

	while (1)
	{
		um.loop();
		Makernet.loop();
		updateMicrosecondCounter();
	}
}

#else // SLAVE

int main(void)
{
	DeviceControlService dcs;
	MailboxService ms;
	Makernet.network.role = Network::slave;
	UnixMaster um;

	Makernet.network.useDatalink( &um );
	Makernet.network.registerService(0, &dcs);

	Makernet.deviceType = DeviceType::Encoder;

	Makernet.initialize();

	startMicrosecondCounter();

	while (1)
	{
		um.loop();
		Makernet.loop();
		updateMicrosecondCounter();
	}


}

#endif

